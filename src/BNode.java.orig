import java.util.Arrays;
import java.util.Comparator;

<<<<<<< HEAD
public class BNode {
	
	private BNode parent;
	private BNode[] children;
	private int[] keys;
	
	private int maxNodes;
	private int nKeys;

	private boolean isLeaf;
	
	public BNode(int t) {
		nKeys 	 = 0;
		maxNodes = (2 * t) - 1;
		children = new BNode[maxNodes + 1];
		keys 	 = new int[maxNodes];
		isLeaf 	 = true;
		parent 	 = null;
	}
	
	public BNode(int t, int key) {
		nKeys 	 = 0;
		maxNodes = (2 * t) - 1;
		children = new BNode[maxNodes + 1];
		keys 	 = new int[maxNodes];
		isLeaf 	 = true;
		parent	 = null;
		keys[0]  = key; 
	}
	
	public boolean isFull() {
		return nKeys == maxNodes;
	}
	
	public int getMaxNodes(){
		return maxNodes;
	}
	
	public final int[] getKeys() {
	    return keys;
	}
	
	public final boolean isLeaf() {
	    return isLeaf;
	}
	
	public void setNoLeaf(){
		isLeaf = false;
	}
	
	public final BNode[] getChildren() {
	    return children;
	}

	public int getNumberOfKeys(){
		return nKeys;
	}
	
	public BNode getParent(){
		return parent;
	}
	
	public void setParent(BNode parent){
		this.parent = parent;
	}
	
	public void addKey(int key){
			keys[nKeys] = key;
			nKeys++;
			Arrays.sort(keys);
	}
	
	public int getPosition(int key){
		for(int i = 0; i < getNumberOfKeys(); i++){
			if (key == getKeys()[i])
				return i;
		}
	}
	
	/*
	public void addKey(int key, BNode childrenLeft, BNode childrenRight){
			//encontrar o lugar para add a nova chave
			int i = 0;
			for (int key_in_node : getKeys()) {
				if(key_in_node > key)
					break;
				i++;
			}
			//inserir nova chave e mover chaves e filhos para o lugar correto
			int[] new_keys = new int[maxNodes];
			BNode[] new_children = new BNode[maxNodes+1];

			for(int j=0; j <= nKeys; j++){
				if(j == i){
					new_keys[j] = key;
					new_children[j] = children[j];
					j++;
				} else {
					new_keys[j] = keys[j];
				}
			}
			keys = new_keys;
		}*/
=======
@SuppressWarnings("unchecked")
public class BNode<T> {
	private BData<T>[] nodeData;
	private BNode<T>[] children;
	private BNode<T> parent;
	private int maxNodes;
	private int nNodes;
	private boolean isLeaf;
	private int t;
	
	public BNode(int t) {
		nNodes = 0;
		this.t = t;
		maxNodes = 2 * t - 1;
		nodeData = (BData<T>[]) new BData<?>[maxNodes];
		children = (BNode<T>[]) new BNode<?>[maxNodes + 1];
		isLeaf = true;
	}

	public void add(T data, int key) {
		nodeData[nNodes++] = new BData<T>(key, data);
		Arrays.sort(nodeData, 0, nNodes);
		Arrays.sort(children, new Comparator<BNode<T>>() {

			@Override
			public int compare(BNode<T> o1, BNode<T> o2) {
				if (o1 == null || o2 == null)
					return 0;
				
				return o1.maxKey() - o2.maxKey();
			}
			
		});
	}
	
	protected void add(BData<T> data) {
		add(data.getData(), data.getKey());
	}
	
	public BData<T> median() {
		return nodeData[nNodes/2];
	}
	
	public BNode<T> medianLeft() {
		BNode<T> result = new BNode<T>(t);
		
		
		for (int i = 0; i < nNodes/2; i++)
			result.add(nodeData[i]);
				
		return result;
	}
	
	public BNode<T> medianRight() {
		BNode<T> result = new BNode<T>(t);
				
		for (int i = nNodes/2 + 1; i < nodeData.length; i++)
			result.add(nodeData[i]);
				
		return result;
	}
	
	public int maxKey() {
		return nodeData[nNodes - 1].getKey();
	}
	
	public void splitChild(BNode<T> child) {
		int i;
		
		for (i = 0; i < children.length && children[i] != child; i++);
				
		BNode<T> nodesLeft = children[i].medianLeft();
		BNode<T> nodesRight = children[i].medianRight();
		
		nodesLeft.setLeaf(true);
		nodesRight.setLeaf(true);
		
		children[i] = nodesLeft;
		
		for (int j = children.length - 2; j >= i + 1; j--) {
			children[j + 1] = children[j];
		}
		
		children[i + 1] = nodesRight;
	}
	
	public void setChildren(BNode<T>[] children) {		
		
		for (BNode<T> c: children)
			if (c != null)
				c.setParent(this);
		
		this.children = children;
	}

	public BNode<T>[] getChildren() {
		return children;
>>>>>>> d4baf07f6150dd4f2d08a10efb2c4f37c8ff44b6
	}
	
/*	public void addNode(T data, int key) {
		nodeData[nNodes++] = new BNodeData<T>(data, key);

		Arrays.sort(nodeData);
	}

	public BNode<T> getChildrenByKey(int key) {
		int i = 0;
				
		while (i < nodeData.length && key > nodeData[i].getKey()) {
			i++;
		}
		
		return children[i];
	}
	
	@Override
	public String toString() {
		return "| " + Arrays.toString(nodeData) + " |";
	}

	public boolean isLeaf() {
		return isLeaf;
	}

<<<<<<< HEAD
		return data.getLess();
	}*/
=======
	public void setLeaf(boolean isLeaf) {
		this.isLeaf = isLeaf;
	}

	public BNode<T> getParent() {
		return parent;
	}

	public void setParent(BNode<T> parent) {
		this.parent = parent;
	}

>>>>>>> d4baf07f6150dd4f2d08a10efb2c4f37c8ff44b6
}
