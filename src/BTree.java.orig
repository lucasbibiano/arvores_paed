<<<<<<< HEAD
import java.util.ArrayList;

public class BTree {
	private BNode root;

	public BTree(int t) {
		setRoot(new BNode(t));
	}
	
	public BNode getRoot() {
		return root;
	}

	public void setRoot(BNode root) {
		this.root = root;
=======
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Queue;

public class BTree<T> {
	private BNode<T> root;
	private int t;

	public BTree(int t) {
		setRoot(new BNode<T>(t));
		this.t = t;
	}

	public void insertValue(T value, int key) {
		BNode<T> whereToInsert = getRoot();

		while (!whereToInsert.isLeaf()) {
			whereToInsert = whereToInsert.getChildrenByKey(key);
		}
		
		System.out.println(value.toString());
		
		if (whereToInsert.isFull()) {
			split(whereToInsert);
		}
		else
			whereToInsert.add(value, key);
	}
	
	@SuppressWarnings("unchecked")
	private void split(BNode<T> whereToInsert) {
		if (whereToInsert == getRoot()) {
			BNode<T> newRoot = new BNode<T>(t);
			
			newRoot.add(whereToInsert.median());
			
			BNode<T> nodesLeft = whereToInsert.medianLeft();
			BNode<T> nodesRight = whereToInsert.medianRight();
			
			nodesLeft.setLeaf(true);
			nodesRight.setLeaf(true);
			newRoot.setLeaf(false);
			
			newRoot.setChildren(concat((BNode<T>[]) new BNode<?>[] { nodesLeft, nodesRight }, nullPadding()));
			
			setRoot(newRoot);
		}
		else {
			whereToInsert.getParent().add(whereToInsert.median());
			
			whereToInsert.getParent().splitChild(whereToInsert);
			
			whereToInsert.setLeaf(false);
		}
	}
	
	private BNode<T>[] nullPadding() {
		return (BNode<T>[]) new BNode<?>[2 * t - 1 - 2];
	}

	public static <T> T[] concat(T[] first, T[] second) {
		  T[] result = Arrays.copyOf(first, first.length + second.length);
		  System.arraycopy(second, 0, result, first.length, second.length);
		  return result;
	}

	public void printTree() {		
		Queue<BNode<T>> queue = new ArrayDeque<BNode<T>>();
		int k = 1;
		int i = 0;

		queue.offer((BNode<T>) getRoot());

		while (!queue.isEmpty())
		{
			BNode<T> node = (BNode<T>) queue.poll();
			i++;

			if (k == i)
			{
				k = k * 2;
				System.out.println();
			}

			System.out.print(node.toString());
			
			BNode<T>[] children = node.getChildren();
			
			for (int j = 0; j < children.length; j++) {
				if (children[j] == null)
					continue;
				
				queue.offer(children[j]);
			}
		}

		System.out.println("=====================");
>>>>>>> d4baf07f6150dd4f2d08a10efb2c4f37c8ff44b6
	}

	public void insertValue(int key) {
		BNode whereToInsert = searchHelper(getRoot(), key);
		
		if(!whereToInsert.isFull()){
			whereToInsert.addKey(key);
		} else {
				
		}
	}
	
	public BNode split (BNode node){
		int max_node = node.getMaxNodes();
		int middle = (max_node-1)/2;
		BNode new_node = new BNode(max_node, node.getKeys()[middle]);
		new_node.setParent(node.getParent());
		
		BNode new_children_left = new BNode(max_node);
		BNode new_children_right = new BNode(max_node);

		for (int i = 0; i < middle; i++) {
			new_children_left.getKeys()[i] = node.getKeys()[i];
			new_children_right.getKeys()[max_node-i] = node.getKeys()[max_node-i];
		}
		
		new_children_left.setParent(new_node);
		new_children_right.setParent(new_node);
		
		BNode[] children = new_node.getChildren();
		children[0] = new_children_left;
		children[1] = new_children_right;
		
		new_node.setNoLeaf();
		
		return new_node;
	}
	
	public Integer search(int key){
		BNode node = searchHelper(getRoot(), key);
		
		if(node == null)
			return null;
		
		return node.getPosition(key);
	}
	
	private BNode searchHelper(BNode node, int key){
		if(node.isLeaf())
			return node;
		
		int[] keys = node.getKeys();
		
		for (int i = 0; i < node.getNumberOfKeys(); i++) {
			int key_in_node = keys[i];
			
			if(key_in_node == key)
				return node;
			if(key_in_node > key)
				searchHelper(node.getChildren()[i], key);
			if(key_in_node < key && i == (node.getNumberOfKeys()-1))
				searchHelper(node.getChildren()[i+1], key);
		}
		
		return null;
	}
	
	public void inOrdem(BNode node){
		if (node != null){
			for (int i = 0; i <= node.getNumberOfKeys(); i++){
				inOrdem(node.getChildren()[i]);
				
				if(i < node.getNumberOfKeys())
					System.out.println(node.getKeys()[i]);
			}
			inOrdem(node.getChildren()[i]);
		}
	}
}
